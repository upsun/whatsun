package rules

import (
	"fmt"
	"io"
	"os"
	"sort"
	"strings"
	"what/internal/eval/celfuncs"

	"github.com/google/cel-go/cel"
)

// GenerateDocs generates documentation for CEL functions.
func GenerateDocs(w io.Writer) error {
	root := "."
	celOptions := defaultEnvOptions(os.DirFS("."), &root)
	env, err := cel.NewEnv(celOptions...)
	if err != nil {
		return err
	}

	functions := env.Functions()
	sortedNames := make([]string, len(functions))
	i := 0
	for name := range functions {
		sortedNames[i] = name
		i++
	}
	sort.Strings(sortedNames)

	categories := []string{"Custom functions", "Built-in functions", "Operators"}
	perCategory := make(map[string]string, len(categories))

	for _, name := range sortedNames {
		f := functions[name]

		// TODO find a better way to determine custom functions
		isCustom := strings.Contains(name, ".")
		isOperator := name[0] == '_' || strings.HasSuffix(name, "_")
		category := "Built-in functions"
		if isCustom {
			category = "Custom functions"
		} else if isOperator {
			category = "Operators"
		}

		b := strings.Builder{}

		if isOperator {
			b.WriteString(fmt.Sprintf("* **`%s`**\n", strings.Trim(strings.ReplaceAll(name, "_", " "), "_ ")))
		} else {
			if comment, ok := celfuncs.FuncComments[name]; ok {
				b.WriteString(fmt.Sprintf("* **`%s`**: %s\n", name, comment))
			} else {
				b.WriteString(fmt.Sprintf("* **`%s`**\n", name))
			}
		}

		for _, overload := range f.OverloadDecls() {
			argTypes := overload.ArgTypes()
			var argTypesStr = make([]string, len(argTypes))
			for i, at := range argTypes {
				argTypesStr[i] = at.String()
			}
			if overload.IsMemberFunction() {
				b.WriteString(fmt.Sprintf("  - `<%s>.%s(%s)` -> `%s`\n", argTypesStr[0], name, strings.Join(argTypesStr[1:], ", "), overload.ResultType()))
			} else if isOperator {
				descr := f.Name()
				for _, argTypeStr := range argTypesStr {
					descr = strings.Replace(descr, "_", "` `"+argTypeStr+"` `", 1)
				}
				b.WriteString(fmt.Sprintf("  - `%s` -> `%s`\n", strings.Trim(descr, " `"), overload.ResultType()))
			} else {
				b.WriteString(fmt.Sprintf("  - `%s(%s)` -> `%s`\n", f.Name(), strings.Join(argTypesStr, ", "), overload.ResultType()))
			}
		}

		if _, ok := perCategory[category]; !ok {
			perCategory[category] = ""
		}
		perCategory[category] += b.String()
	}

	b := strings.Builder{}
	b.WriteString("# CEL function and operator documentation\n\n")
	b.WriteString("This file is generated by `make gen_doc` (DO NOT EDIT).\n\n")
	for _, category := range categories {
		b.WriteString("\n## " + category + "\n")
		b.WriteString(perCategory[category])
	}

	_, err = fmt.Fprint(w, b.String())
	return err
}
